#!/bin/bash

# If VERBOSE is true, then output line-by-line execution
"${VERBOSE:-false}" && set -x
"${EXIT_ON_FAILURE:-false}" && set -e

########################################################################################################################
#
# PREREQUISITES: Should be compatible with Debian.
#                This script is used by platform automation on Ubuntu (Debian) to generate K8s manifest.
#
# Note: This script must be executed within its git checkout tree after switching to the desired branch.
#
# This script may be used to generate the initial Kubernetes configurations to push into the cluster-state repository
# for a particular tenant. This repo is referred to as the cluster state repo because the EKS clusters are always
# (within a few minutes) reflective of the code in this repo. This repo is the only interface for updates to the
# clusters. In other words, kubectl commands that alter the state of the cluster are verboten outside of this repo.
#
# The intended audience of this repo is primarily the Ping Professional Services and Support team, with limited access
# granted to Customer administrators. These users may further tweak the cluster state per the tenant's requirements.
# They are expected to have an understanding of Kubernetes manifest files and kustomize, a client-side tool used to make
# further customizations to the initial state generated by this script.
#
# The script generates Kubernetes manifest files for the environments passed in by the SUPPORTED_ENVIRONMENT_TYPES
# environment variable. The manifest files for these environments contain deployments of both the Ping Cloud stack and
# the supporting tools necessary to provide an end-to-end solution.
#
# For example, the script produces a directory structure as shown below (Directories greater than a depth of 3 and
# files within the directories are omitted for brevity):
#
# ├── cluster-state
# │  └── k8s-configs
# │     ├── dev
# │     ├── prod
# │     ├── stage
# │     └── test
# │  └── profiles
# └── fluxcd
#    ├── dev
#    ├── prod
#    ├── stage
#    └── test
#
# Deploying the manifests under the fluxcd directory for a specific environment will bootstrap the cluster with a
# Continuous Delivery tool. Once the CD tool is deployed to the cluster, it will deploy the rest of the ping stack
# and supporting tools for that environment.
#
# ------------
# Requirements
# ------------
# The script requires the following tools to be installed:
#   - openssl
#   - ssh-keygen
#   - ssh-keyscan
#   - base64
#   - envsubst
#   - git
#   - rsync
#
# ------------------
# Usage instructions
# ------------------
# The script does not take any parameters, but rather acts on environment variables. The environment variables will
# be substituted into the variables in the yaml template files.
#
# The environment variables within interface-env-vars.md, if present, will be used. See the markdown files for the defaults.

#### SCRIPT START ####

# Ensure that this script works from any working directory.
SCRIPT_HOME=$(cd $(dirname ${0}) 2>/dev/null; pwd)
pushd "${SCRIPT_HOME}" >/dev/null 2>&1

# Quiet mode where instructional messages are omitted.
QUIET="${QUIET:-false}"

# Source some utility methods.
. ../utils.sh

# Source aws specific utility methods.
. ./aws/utils.sh

########################################################################################################################
# Substitute variables in all template files in the provided directory.
#
# Arguments
#   ${1} -> The directory that contains the template files.
########################################################################################################################

# The list of variables in the template files that will be substituted by default.
# Note: DEFAULT_VARS is a superset of ENV_VARS_TO_SUBST within update-cluster-state.sh. These variables should be kept
# in sync with the following exceptions: LAST_UPDATE_REASON and NEW_RELIC_LICENSE_KEY_BASE64 should only be found
# within DEFAULT_VARS
# Note: only secret variables are substituted into YAML files. Environments variables are just written to an env_vars
# file and substituted at runtime by the continuous delivery tool running in cluster.
# shellcheck disable=SC2016
DEFAULT_VARS='${LAST_UPDATE_REASON}
${PING_IDENTITY_DEVOPS_USER}
${PING_IDENTITY_DEVOPS_KEY}
${NEW_RELIC_LICENSE_KEY_BASE64}
${TENANT_NAME}
${SSH_ID_KEY_BASE64}
${IS_MULTI_CLUSTER}
${PLATFORM_EVENT_QUEUE_NAME}
${CUSTOMER_SSO_SSM_PATH_PREFIX}
${ORCH_API_SSM_PATH_PREFIX}
${SERVICE_SSM_PATH_PREFIX}
${REGION}
${REGION_NICK_NAME}
${PRIMARY_REGION}
${TENANT_DOMAIN}
${PRIMARY_TENANT_DOMAIN}
${PRIMARY_TENANT_DOMAIN_DERIVED}
${SECONDARY_TENANT_DOMAINS}
${GLOBAL_TENANT_DOMAIN}
${ARTIFACT_REPO_URL}
${PING_ARTIFACT_REPO_URL}
${PD_MONITOR_BUCKET_URL}
${LOG_ARCHIVE_URL}
${BACKUP_URL}
${PGO_BACKUP_BUCKET_NAME}
${PING_CLOUD_NAMESPACE}
${K8S_GIT_URL}
${K8S_GIT_BRANCH}
${ECR_REGISTRY_NAME}
${KNOWN_HOSTS_CLUSTER_STATE_REPO}
${CLUSTER_STATE_REPO_URL}
${CLUSTER_STATE_REPO_BRANCH}
${CLUSTER_STATE_REPO_PATH_DERIVED}
${SERVER_PROFILE_URL}
${SERVER_PROFILE_BRANCH_DERIVED}
${SERVER_PROFILE_PATH}
${ENV}
${ENVIRONMENT_TYPE}
${KUSTOMIZE_BASE}
${LETS_ENCRYPT_SERVER}
${USER_BASE_DN}
${USER_BASE_DN_2}
${USER_BASE_DN_3}
${USER_BASE_DN_4}
${USER_BASE_DN_5}
${ADMIN_CONSOLE_BRANDING}
${ENVIRONMENT_PREFIX}
${NEW_RELIC_ENVIRONMENT_NAME}
${PF_PD_BIND_PORT}
${PF_PD_BIND_PROTOCOL}
${PF_PD_BIND_USESSL}
${PF_MIN_HEAP}
${PF_MAX_HEAP}
${PF_MIN_YGEN}
${PF_MAX_YGEN}
${PA_WAS_MIN_HEAP}
${PA_WAS_MAX_HEAP}
${PA_WAS_MIN_YGEN}
${PA_WAS_MAX_YGEN}
${PA_WAS_GCOPTION}
${PA_MIN_HEAP}
${PA_MAX_HEAP}
${PA_MIN_YGEN}
${PA_MAX_YGEN}
${PA_GCOPTION}
${MYSQL_SERVICE_HOST}
${MYSQL_USER}
${MYSQL_PASSWORD}
${MYSQL_DATABASE}
${CLUSTER_NAME}
${CLUSTER_NAME_LC}
${CLUSTER_ENDPOINT}
${DNS_ZONE}
${DNS_ZONE_DERIVED}
${PRIMARY_DNS_ZONE}
${PRIMARY_DNS_ZONE_DERIVED}
${METADATA_IMAGE_TAG}
${BOOTSTRAP_IMAGE_TAG}
${P14C_INTEGRATION_IMAGE_TAG}
${ANSIBLE_BELUGA_IMAGE_TAG}
${PINGCENTRAL_IMAGE_TAG}
${PINGACCESS_IMAGE_TAG}
${PINGACCESS_WAS_IMAGE_TAG}
${PINGFEDERATE_IMAGE_TAG}
${PINGDIRECTORY_IMAGE_TAG}
${PINGDELEGATOR_IMAGE_TAG}
${IRSA_PING_ANNOTATION_KEY_VALUE}
${IRSA_PA_ANNOTATION_KEY_VALUE}
${IRSA_PD_ANNOTATION_KEY_VALUE}
${IRSA_PF_ANNOTATION_KEY_VALUE}
${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}
${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}
${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}
${NOTIFICATION_ENABLED}
${NOTIFICATION_ENDPOINT}
${PF_PROVISIONING_ENABLED}
${RADIUS_PROXY_ENABLED}
${EXTERNAL_INGRESS_ENABLED}
${IMAGE_TAG_PREFIX}
${ARGOCD_BOOTSTRAP_ENABLED}
${ARGOCD_CDE_ROLE_SSM_TEMPLATE}
${ARGOCD_CDE_URL_SSM_TEMPLATE}
${ARGOCD_ENVIRONMENTS}
${ARGOCD_SLACK_TOKEN_BASE64}
${SLACK_CHANNEL}
${PROM_SLACK_CHANNEL}
${DASH_REPO_URL}
${DASH_REPO_BRANCH}
${APP_RESYNC_SECONDS}
${IMAGE_LIST}'

# Variables to replace within the generated cluster state code
REPO_VARS="${REPO_VARS:-${DEFAULT_VARS}}"

# Variables to replace in the generated bootstrap code
BOOTSTRAP_VARS='${APP_RESYNC_SECONDS}
${ARGOCD_BOOTSTRAP_ENABLED}
${ARGOCD_CDE_ROLE_SSM_TEMPLATE}
${ARGOCD_CDE_URL_SSM_TEMPLATE}
${ARGOCD_ENVIRONMENTS}
${CLUSTER_STATE_REPO_BRANCH}
${CLUSTER_STATE_REPO_URL}
${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}
${K8S_GIT_BRANCH}
${K8S_GIT_URL}
${KNOWN_HOSTS_CLUSTER_STATE_REPO}
${PGO_BACKUP_BUCKET_NAME}
${PING_CLOUD_NAMESPACE}
${REGION_NICK_NAME}
${REGION}
${SLACK_CHANNEL}
${SSH_ID_KEY_BASE64}
${TENANT_NAME}'


########################################################################################################################
# Export some derived environment variables.
########################################################################################################################
add_derived_variables() {
  # The directory within the cluster state repo for the region's manifest files.
  export CLUSTER_STATE_REPO_PATH_DERIVED="\${REGION_NICK_NAME}"

  # Server profile branch. The directory is in each app's env_vars file.
  export SERVER_PROFILE_BRANCH_DERIVED="\${CLUSTER_STATE_REPO_BRANCH}"

  # Zone for this region and the primary region.
  export DNS_ZONE_DERIVED="\${DNS_ZONE}"
  export PRIMARY_DNS_ZONE_DERIVED="\${PRIMARY_DNS_ZONE}"

  # Zone for this region and the primary region.
  if "${IS_BELUGA_ENV}" || test "${ENV}" = "${CUSTOMER_HUB}"; then
    export DNS_ZONE="\${TENANT_DOMAIN}"
    export PRIMARY_DNS_ZONE="\${PRIMARY_TENANT_DOMAIN}"
  else
    export DNS_ZONE="\${REGION_ENV}-\${TENANT_DOMAIN}"
    export PRIMARY_DNS_ZONE="\${ENV}-\${PRIMARY_TENANT_DOMAIN}"
  fi

  export PRIMARY_TENANT_DOMAIN_DERIVED="\${PRIMARY_TENANT_DOMAIN}"

  # This variable's value will make it onto the branding for all admin consoles and
  # will include the name of the environment and the region where it's deployed.
  export ADMIN_CONSOLE_BRANDING="\${ENV}-\${REGION}"

  # This variable's value will be used as the prefix to distinguish between worker apps for different CDEs for a
  # single P14C tenant. All of these apps will be created within the "Administrators" environment in the tenant.
  export ENVIRONMENT_PREFIX="\${TENANT_NAME}-\${REGION_ENV}-\${REGION_NICK_NAME}"

  # The name of the environment as it will appear on the NewRelic console.
  export NEW_RELIC_ENVIRONMENT_NAME="\${TENANT_NAME}_\${REGION_ENV}_\${REGION_NICK_NAME}_k8s-cluster"
}

########################################################################################################################
# Export the IS_GA environment variable for the provided customer. If it's already present as a boolean environment
# variable, then export it as is. Otherwise, if the SSM path prefix for it is not 'unused', then try to retrieve it out
# of SSM. On error, print a warning message, but default the value to false. On success, use the value from SSM, if it
# is a valid boolean. Otherwise, default it to false.
#
# Arguments
#   ${1} -> The value of the IS_GA flag.
########################################################################################################################
get_is_ga_variable() {
  if test "${IS_GA}" = 'true' || test "${IS_GA}" = 'false'; then
    export IS_GA="${IS_GA}"
    return
  fi

  local ssm_path_prefix="$1"

  # Default false
  IS_GA='false'

  if [ "${ssm_path_prefix}" != "unused" ]; then
    # Getting value from ssm parameter store.
    if ! ssm_value=$(get_ssm_value "${ssm_path_prefix}"); then
      echo "Warn: ${ssm_value}"
      echo "Defaulting IS_GA=false."
    else
      IS_GA="${ssm_value}"
    fi
  fi

  if test "${IS_GA}" = 'true' || test "${IS_GA}" = 'false'; then
    export IS_GA="${IS_GA}"
  else
    export IS_GA='false'
  fi
}

########################################################################################################################
# Export the IS_MY_PING environment variable for the provided customer. If it's already present as a boolean environment
# variable, then export it as is. Otherwise, if the SSM path prefix for it is not 'unused', then try to retrieve it out
# of SSM. On error, print a warning message, but default the value to false. On success, use the value from SSM.
# Otherwise, default it to false.
#
# Arguments
#   ${1} -> The value of the IS_MY_PING flag.
########################################################################################################################
get_is_myping_variable() {
  if test "${IS_MY_PING}" = 'true' || test "${IS_MY_PING}" = 'false'; then
    export IS_MY_PING="${IS_MY_PING}"
    return
  fi

  local ssm_path_prefix="$1"

  # Default false
  IS_MY_PING='false'

  if [ "${ssm_path_prefix}" != "unused" ]; then
    # Getting value from ssm parameter store.
    if ! ssm_value=$(get_ssm_value "${ssm_path_prefix}"); then
      echo "Warn: ${ssm_value}"
      echo "Defaulting IS_MY_PING=false."
    else
      IS_MY_PING="${ssm_value}"
    fi
  fi

  if test "${IS_MY_PING}" = 'true' || test "${IS_MY_PING}" = 'false'; then
    export IS_MY_PING="${IS_MY_PING}"
  else
    export IS_MY_PING='false'
  fi
}

# Support the various ways to actually set the SSH key pair env vars
set_ssh_key_pair() {
  # Autogenerate if no keys provided
  if test -z "${SSH_ID_PUB_FILE}" && test -z "${SSH_ID_KEY_FILE}"; then
    echo 'Generating key-pair for SSH access'
    generate_ssh_key_pair

  # Upgrade flow - we only get a private key from update-cluster-state.sh
  elif test -z "${SSH_ID_PUB_FILE}" && test -f "${SSH_ID_KEY_FILE}"; then
    echo 'This is an upgrade - using provided private key for SSH access. No public key available'
    export SSH_ID_KEY_BASE64=$(base64_no_newlines "${SSH_ID_KEY_FILE}")

  # Both public file and key file provided
  elif test -f "${SSH_ID_PUB_FILE}" && test -f "${SSH_ID_KEY_FILE}"; then
    echo 'Using provided key-pair for SSH access'
    export SSH_ID_PUB=$(cat "${SSH_ID_PUB_FILE}")
    export SSH_ID_KEY_BASE64=$(base64_no_newlines "${SSH_ID_KEY_FILE}")

  # Unsupported flow - no private key provided at all or not a file
  else
    echo 'Provide SSH key-pair files via SSH_ID_PUB_FILE/SSH_ID_KEY_FILE env vars, or omit both for key-pair to be generated'
    exit 1
  fi
}

# Organizes the files from code-gen directory to a tmp directory for push-cluster-state script
organize_code_for_csr() {
  # find all the apps under code-gen/templates directory
  local app_paths=$(find "${TEMPLATES_HOME}" -maxdepth 1 -mindepth 1 -type d ! -path '*/cde' ! -path '*/common' ! -path '*/customer-hub' ! -path '*/fluxcd')

  for app_path in ${app_paths}; do
    local app_name=$(basename "${app_path}")

    # source the config or continue to next app if config not there
    source "${app_path}/config.sh" || continue

    echo ---
    echo "For app '${app_name}':"
    echo "Using CDE_DEPLOY: ${CDE_DEPLOY}"
    echo "Using CHUB_DEPLOY:  ${CHUB_DEPLOY}"
    echo

    # Add the app directory to the tmp directory if the deploy env var aligns with the env env var
    if (test "${ENV}" = "${CUSTOMER_HUB}" && ${CHUB_DEPLOY}) || (test "${ENV}" != "${CUSTOMER_HUB}" && ${CDE_DEPLOY}); then
      local app_target_dir=${ENV_DIR}/${app_name}
      mkdir -p "${app_target_dir}"

      cd "${app_path}"
      rsync -rR * --exclude config.sh "${app_target_dir}"
      cd - >/dev/null 2>&1

      # Rename to the actual region nick name.
      mv "${app_target_dir}/region" "${app_target_dir}/${REGION_NICK_NAME}"
    fi
  done
}

# Checking required tools and environment variables.
check_binaries "openssl" "ssh-keygen" "ssh-keyscan" "base64" "envsubst" "git" "aws" "rsync"
HAS_REQUIRED_TOOLS=${?}

if test ${HAS_REQUIRED_TOOLS} -ne 0; then
  # Go back to previous working directory, if different, before exiting.
  popd >/dev/null 2>&1
  exit 1
fi

if test -z "${IS_MULTI_CLUSTER}"; then
  IS_MULTI_CLUSTER=false
fi


########################################################################################################################
# Print out the initial values provided for each variable.
########################################################################################################################
echo "Initial TENANT_NAME: ${TENANT_NAME}"
echo "Initial SIZE: ${SIZE}"

echo "Initial SUPPORTED_ENVIRONMENT_TYPES: ${SUPPORTED_ENVIRONMENT_TYPES}"
echo "Initial ENVIRONMENTS: ${ENVIRONMENTS}"
echo "Initial IS_MULTI_CLUSTER: ${IS_MULTI_CLUSTER}"
echo "Initial PLATFORM_EVENT_QUEUE_NAME: ${PLATFORM_EVENT_QUEUE_NAME}"
echo "Initial CUSTOMER_SSO_SSM_PATH_PREFIX: ${CUSTOMER_SSO_SSM_PATH_PREFIX}"
echo "Initial ORCH_API_SSM_PATH_PREFIX: ${ORCH_API_SSM_PATH_PREFIX}"
echo "Initial SERVICE_SSM_PATH_PREFIX: ${SERVICE_SSM_PATH_PREFIX}"
echo "Initial REGION: ${REGION}"
echo "Initial REGION_NICK_NAME: ${REGION_NICK_NAME}"
echo "Initial PRIMARY_REGION: ${PRIMARY_REGION}"
echo "Initial TENANT_DOMAIN: ${TENANT_DOMAIN}"
echo "Initial GLOBAL_TENANT_DOMAIN: ${GLOBAL_TENANT_DOMAIN}"
echo "Initial PRIMARY_TENANT_DOMAIN: ${PRIMARY_TENANT_DOMAIN}"
echo "Initial SECONDARY_TENANT_DOMAINS: ${SECONDARY_TENANT_DOMAINS}"

echo "Initial CLUSTER_STATE_REPO_URL: ${CLUSTER_STATE_REPO_URL}"
echo "Initial SERVER_PROFILE_URL: ${SERVER_PROFILE_URL}"

echo "Initial ARTIFACT_REPO_URL: ${ARTIFACT_REPO_URL}"
echo "Initial PING_ARTIFACT_REPO_URL: ${PING_ARTIFACT_REPO_URL}"

echo "Initial PD_MONITOR_BUCKET_URL: ${PD_MONITOR_BUCKET_URL}"
echo "Initial LOG_ARCHIVE_URL: ${LOG_ARCHIVE_URL}"
echo "Initial BACKUP_URL: ${BACKUP_URL}"

echo "Initial MYSQL_SERVICE_HOST: ${MYSQL_SERVICE_HOST}"
echo "Initial MYSQL_USER: ${MYSQL_USER}"
echo "Initial MYSQL_PASSWORD: ${MYSQL_PASSWORD}"

echo "Initial PING_IDENTITY_DEVOPS_USER: ${PING_IDENTITY_DEVOPS_USER}"

echo "Initial K8S_GIT_URL: ${K8S_GIT_URL}"
echo "Initial K8S_GIT_BRANCH: ${K8S_GIT_BRANCH}"

echo "Initial SSH_ID_PUB_FILE: ${SSH_ID_PUB_FILE}"
echo "Initial SSH_ID_KEY_FILE: ${SSH_ID_KEY_FILE}"

echo "Initial PF_PROVISIONING_ENABLED: ${PF_PROVISIONING_ENABLED}"
echo "Initial PGO_BACKUP_BUCKET_NAME: ${PGO_BACKUP_BUCKET_NAME}"

echo "Initial RADIUS_PROXY_ENABLED: ${RADIUS_PROXY_ENABLED}"
echo "Initial EXTERNAL_INGRESS_ENABLED: ${EXTERNAL_INGRESS_ENABLED}"

echo "Initial ARGOCD_BOOTSTRAP_ENABLED: ${ARGOCD_BOOTSTRAP_ENABLED}"
echo "Initial ARGOCD_CDE_ROLE_SSM_TEMPLATE: ${ARGOCD_CDE_ROLE_SSM_TEMPLATE}"
echo "Initial ARGOCD_CDE_URL_SSM_TEMPLATE: ${ARGOCD_CDE_URL_SSM_TEMPLATE}"
echo "Initial ARGOCD_ENVIRONMENTS: ${ARGOCD_ENVIRONMENTS}"

echo "Initial TARGET_DIR: ${TARGET_DIR}"
echo "Initial IS_BELUGA_ENV: ${IS_BELUGA_ENV}"

echo "Initial ACCOUNT_BASE_PATH: ${ACCOUNT_BASE_PATH}"
echo "Initial PGO_BUCKET_URI_SUFFIX: ${PGO_BUCKET_URI_SUFFIX}"

echo "Initial IRSA_PING_ANNOTATION_KEY_VALUE: ${IRSA_PING_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_PA_ANNOTATION_KEY_VALUE: ${IRSA_PA_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_PD_ANNOTATION_KEY_VALUE: ${IRSA_PD_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_PF_ANNOTATION_KEY_VALUE: ${IRSA_PF_ANNOTATION_KEY_VALUE}"
echo "Initial IRSA_ARGOCD_ANNOTATION_KEY_VALUE: ${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}"
echo "Initial KARPENTER_ROLE_ANNOTATION_KEY_VALUE: ${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}"
echo "Initial NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE: ${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}"

echo "Initial CLUSTER_ENDPOINT: ${CLUSTER_ENDPOINT}"

echo "Initial SLACK_CHANNEL: ${SLACK_CHANNEL}"
echo "Initial NON_GA_SLACK_CHANNEL: ${NON_GA_SLACK_CHANNEL}"
echo "Initial PROM_SLACK_CHANNEL: ${PROM_SLACK_CHANNEL}"

echo "Initial IMAGE_LIST: ${IMAGE_LIST}"
echo "Initial IMAGE_TAG_PREFIX: ${IMAGE_TAG_PREFIX}"

echo "Initial APP_RESYNC_SECONDS: ${APP_RESYNC_SECONDS}"
echo ---


########################################################################################################################
# Set the values for each variable.
########################################################################################################################

# Use defaults for other variables, if not present.
export IS_BELUGA_ENV="${IS_BELUGA_ENV:-false}"

TENANT_DOMAIN="${TENANT_DOMAIN:-ci-cd.ping-oasis.com}"
export TENANT_NAME="${TENANT_NAME:-${TENANT_DOMAIN%%.*}}"
export SIZE="${SIZE:-x-small}"

### Region-specific environment variables ###
export REGION="${REGION:-us-west-2}"
export REGION_NICK_NAME="${REGION_NICK_NAME:-${REGION}}"

TENANT_DOMAIN_NO_DOT_SUFFIX="${TENANT_DOMAIN%.}"
export TENANT_DOMAIN="${TENANT_DOMAIN_NO_DOT_SUFFIX}"

export ARTIFACT_REPO_URL="${ARTIFACT_REPO_URL:-unused}"

export PLATFORM_EVENT_QUEUE_NAME=${PLATFORM_EVENT_QUEUE_NAME:-v2_platform_event_queue.fifo}
export CUSTOMER_SSO_SSM_PATH_PREFIX=${CUSTOMER_SSO_SSM_PATH_PREFIX:-/pcpt/customer/sso}
export ORCH_API_SSM_PATH_PREFIX=${ORCH_API_SSM_PATH_PREFIX:-/pcpt/orch-api}
export SERVICE_SSM_PATH_PREFIX=${SERVICE_SSM_PATH_PREFIX:-/pcpt/service}

export LAST_UPDATE_REASON="${LAST_UPDATE_REASON:-NA}"

### Base environment variables ###
export IS_MULTI_CLUSTER="${IS_MULTI_CLUSTER}"

export PRIMARY_REGION="${PRIMARY_REGION:-${REGION}}"
PRIMARY_TENANT_DOMAIN_NO_DOT_SUFFIX="${PRIMARY_TENANT_DOMAIN%.}"
export PRIMARY_TENANT_DOMAIN="${PRIMARY_TENANT_DOMAIN_NO_DOT_SUFFIX:-${TENANT_DOMAIN_NO_DOT_SUFFIX}}"
export SECONDARY_TENANT_DOMAINS="${SECONDARY_TENANT_DOMAINS}"

if "${IS_BELUGA_ENV}"; then
  DERIVED_GLOBAL_TENANT_DOMAIN="global.${TENANT_DOMAIN_NO_DOT_SUFFIX}"
  # 'yq' is only checked here because it is only used within Developer CDEs
  check_binaries "yq" || { popd >/dev/null 2>&1 && exit 1; }
else
  DERIVED_GLOBAL_TENANT_DOMAIN="$(echo "${TENANT_DOMAIN_NO_DOT_SUFFIX}" | sed -e "s/\([^.]*\).[^.]*.\(.*\)/global.\1.\2/")"
fi
GLOBAL_TENANT_DOMAIN_NO_DOT_SUFFIX="${GLOBAL_TENANT_DOMAIN%.}"
export GLOBAL_TENANT_DOMAIN="${GLOBAL_TENANT_DOMAIN_NO_DOT_SUFFIX:-${DERIVED_GLOBAL_TENANT_DOMAIN}}"

export PING_ARTIFACT_REPO_URL="${PING_ARTIFACT_REPO_URL:-https://ping-artifacts.s3-us-west-2.amazonaws.com}"

export PD_MONITOR_BUCKET_URL="${PD_MONITOR_BUCKET_URL:-ssm://pcpt/service/storage/pd-monitor/uri}"
export LOG_ARCHIVE_URL="${LOG_ARCHIVE_URL:-unused}"
export BACKUP_URL="${BACKUP_URL:-unused}"

export MYSQL_SERVICE_HOST="${MYSQL_SERVICE_HOST:-"pingcentraldb.${PRIMARY_TENANT_DOMAIN}"}"
export MYSQL_USER="${MYSQL_USER:-ssm://aws/reference/secretsmanager//pcpt/ping-central/dbserver#username}"
export MYSQL_PASSWORD="${MYSQL_PASSWORD:-ssm://aws/reference/secretsmanager//pcpt/ping-central/dbserver#password}"

export PING_IDENTITY_DEVOPS_USER="${PING_IDENTITY_DEVOPS_USER:-ssm://pcpt/devops-license/user}"
export PING_IDENTITY_DEVOPS_KEY="${PING_IDENTITY_DEVOPS_KEY:-ssm://pcpt/devops-license/key}"

PING_CLOUD_BASE_COMMIT_SHA=$(git rev-parse HEAD)
CURRENT_GIT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
if test "${CURRENT_GIT_BRANCH}" = 'HEAD'; then
  CURRENT_GIT_BRANCH=$(git describe --tags --always)
fi

export CLUSTER_STATE_REPO_URL=${CLUSTER_STATE_REPO_URL:-https://github.com/pingidentity/ping-cloud-base}
CLUSTER_STATE_REPO_NAME="${CLUSTER_STATE_REPO_URL##*/}"

SERVER_PROFILE_URL_DERIVED="$(echo "${CLUSTER_STATE_REPO_URL}" | sed -e "s/${CLUSTER_STATE_REPO_NAME}/profile-repo/")"
export SERVER_PROFILE_URL="${SERVER_PROFILE_URL:-${SERVER_PROFILE_URL_DERIVED}}"

export K8S_GIT_URL="${K8S_GIT_URL:-https://github.com/pingidentity/ping-cloud-base.git}"
export K8S_GIT_BRANCH="${K8S_GIT_BRANCH:-${CURRENT_GIT_BRANCH}}"

export SSH_ID_PUB_FILE="${SSH_ID_PUB_FILE}"
export SSH_ID_KEY_FILE="${SSH_ID_KEY_FILE}"

export TARGET_DIR="${TARGET_DIR:-/tmp/sandbox}"

export ACCOUNT_BASE_PATH=${ACCOUNT_BASE_PATH:-ssm://pcpt/config/k8s-config/accounts/}
export IRSA_BASE_PATH=${IRSA_BASE_PATH:-ssm://pcpt/irsa-role/}
export PGO_BUCKET_URI_SUFFIX=${PGO_BUCKET_URI_SUFFIX:-/pgo-bucket/uri}

# IRSA for ping product pods. The role name is predefined as a part of the interface contract.
export IRSA_PING_ANNOTATION_KEY_VALUE=${IRSA_PING_ANNOTATION_KEY_VALUE:-''}
export IRSA_PA_ANNOTATION_KEY_VALUE=${IRSA_PA_ANNOTATION_KEY_VALUE:-''}
export IRSA_PD_ANNOTATION_KEY_VALUE=${IRSA_PD_ANNOTATION_KEY_VALUE:-''}
export IRSA_PF_ANNOTATION_KEY_VALUE=${IRSA_PF_ANNOTATION_KEY_VALUE:-''}
export IRSA_ARGOCD_ANNOTATION_KEY_VALUE=${IRSA_ARGOCD_ANNOTATION_KEY_VALUE:-''}

export CLUSTER_ENDPOINT=${CLUSTER_ENDPOINT:-''}

export KARPENTER_ROLE_ANNOTATION_KEY_VALUE=${KARPENTER_ROLE_ANNOTATION_KEY_VALUE:-''}

export NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE=${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE:-''}

### Variable used by argocd-image-updater to scan container image tags matching the prefix.
export IMAGE_TAG_PREFIX="${K8S_GIT_BRANCH%.*}"

### FEATURE FLAG DEFAULTS ###
export PF_PROVISIONING_ENABLED="${PF_PROVISIONING_ENABLED:-false}"
export RADIUS_PROXY_ENABLED="${RADIUS_PROXY_ENABLED:-false}"
export ARGOCD_BOOTSTRAP_ENABLED="${ARGOCD_BOOTSTRAP_ENABLED:-true}"
export EXTERNAL_INGRESS_ENABLED="${EXTERNAL_INGRESS_ENABLED:-''}"

### Default environment variables ###
export ECR_REGISTRY_NAME='public.ecr.aws/r2h3l6e4'
export PING_CLOUD_NAMESPACE='ping-cloud'
export MYSQL_DATABASE='pingcentral'
export ARGOCD_CDE_ROLE_SSM_TEMPLATE="${ARGOCD_CDE_ROLE_SSM_TEMPLATE:-"/pcpt/config/k8s-config/accounts/{env}/argo/role/arn"}"
export ARGOCD_CDE_URL_SSM_TEMPLATE="${ARGOCD_CDE_URL_SSM_TEMPLATE:-"/pcpt/config/k8s-config/accounts/{env}/cluster/private-link/cname"}"

DEFAULT_IMAGE_LIST="apps=${ECR_REGISTRY_NAME}/pingcloud-apps/pingfederate,apps=${ECR_REGISTRY_NAME}/pingcloud-apps/pingaccess,apps=${ECR_REGISTRY_NAME}/pingcloud-apps/pingaccess-was"
export IMAGE_LIST="${IMAGE_LIST:-${DEFAULT_IMAGE_LIST}}"

ALL_ENVIRONMENTS='dev test stage prod customer-hub'
SUPPORTED_ENVIRONMENT_TYPES="${SUPPORTED_ENVIRONMENT_TYPES:-${ALL_ENVIRONMENTS}}"

if [[ "${UPGRADE}" == "true" ]]; then
  # We want to keep the original value of ARGOCD_ENVIRONMENTS from CSR generation, if this is an upgrade
  export ARGOCD_ENVIRONMENTS="${ARGOCD_ENVIRONMENTS}"
else
  # As of this change (PDO-5017), ENVIRONMENTS is now only used to set ARGOCD_ENVIRONMENTS
  export ARGOCD_ENVIRONMENTS="${ENVIRONMENTS:-${SUPPORTED_ENVIRONMENT_TYPES}}"
fi

# Set Slack-related environment variables and override it's values depending on IS_GA value.
get_is_ga_variable '/pcpt/stage/is-ga'
export NON_GA_SLACK_CHANNEL="${NON_GA_SLACK_CHANNEL:-nowhere}"
# If IS_GA=true, use default Slack channel; if IS_GA=false, use NON_GA_SLACK_CHANNEL value as Slack channel.
if "${IS_GA}"; then
  export SLACK_CHANNEL="${SLACK_CHANNEL:-p1as-application-oncall}"
  export PROM_SLACK_CHANNEL="${PROM_SLACK_CHANNEL:-p1as-application-oncall}"
else
  export SLACK_CHANNEL="${SLACK_CHANNEL:-${NON_GA_SLACK_CHANNEL}}"
  export PROM_SLACK_CHANNEL="${PROM_SLACK_CHANNEL:-${NON_GA_SLACK_CHANNEL}}"
fi

NEW_RELIC_LICENSE_KEY="${NEW_RELIC_LICENSE_KEY:-ssm://pcpt/sre/new-relic/java-agent-license-key}"
if [[ ${NEW_RELIC_LICENSE_KEY} == "ssm://"* ]]; then
  if ! ssm_value=$(get_ssm_value "${NEW_RELIC_LICENSE_KEY#ssm:/}"); then
    echo "Warn: ${ssm_value}"
    echo "Setting NEW_RELIC_LICENSE_KEY to unused"
    NEW_RELIC_LICENSE_KEY="unused"
  else
    NEW_RELIC_LICENSE_KEY="${ssm_value}"
  fi
fi

export NEW_RELIC_LICENSE_KEY_BASE64=$(base64_no_newlines "${NEW_RELIC_LICENSE_KEY}")

# Adding an ArgoCD notification slack token
ARGOCD_SLACK_TOKEN_SSM_PATH="${ARGOCD_SLACK_TOKEN_SSM_PATH:-ssm://pcpt/argocd/notification/slack/access_token}"
if ! ssm_value=$(get_ssm_value "${ARGOCD_SLACK_TOKEN_SSM_PATH#ssm:/}"); then
  echo "Warn: ${ssm_value}"
  echo "ARGOCD_SLACK_TOKEN is unset, slack notification and argo-events will not work"
  echo "Using default invalid token"
  ARGOCD_SLACK_TOKEN="using_default_invalid_token"
else
  ARGOCD_SLACK_TOKEN="${ssm_value}"
fi

export ARGOCD_SLACK_TOKEN_BASE64=$(base64_no_newlines "${ARGOCD_SLACK_TOKEN}")

set_ssh_key_pair

# Get the known hosts contents for the cluster state repo host to pass it into the CD container.
parse_url "${CLUSTER_STATE_REPO_URL}"
echo "Obtaining known_hosts contents for cluster state repo host: ${URL_HOST}"

if test ! "${KNOWN_HOSTS_CLUSTER_STATE_REPO}"; then
  # For GitHub, use the 'ecdsa' SSH host key type. The CD tool doesn't work with RSA keys. For all others, use 'rsa'.
  # FIXME: make SSH_HOST_KEY_TYPE overridable in the future. Ref: "man ssh-keyscan".
  if echo "${URL_HOST}" | grep -q 'github.com'; then
    SSH_HOST_KEY_TYPE='ecdsa'
  else
    SSH_HOST_KEY_TYPE='rsa'
  fi
  KNOWN_HOSTS_CLUSTER_STATE_REPO="$(ssh-keyscan -t "${SSH_HOST_KEY_TYPE}" -H "${URL_HOST}" 2>/dev/null)"
fi
export KNOWN_HOSTS_CLUSTER_STATE_REPO

get_is_myping_variable '/pcpt/orch-api/is-myping'

# Set some product specific variables
export USER_BASE_DN="${USER_BASE_DN:-dc=example,dc=com}"
export USER_BASE_DN_2="${USER_BASE_DN_2}"
export USER_BASE_DN_3="${USER_BASE_DN_3}"
export USER_BASE_DN_4="${USER_BASE_DN_4}"
export USER_BASE_DN_5="${USER_BASE_DN_5}"

export PA_WAS_GCOPTION='-XX:+UseParallelGC'
export PA_MIN_HEAP=1024m
export PA_MAX_HEAP=1024m
export PA_MIN_YGEN=512m
export PA_MAX_YGEN=512m
export PA_GCOPTION='-XX:+UseParallelGC'

export APP_RESYNC_SECONDS="${APP_RESYNC_SECONDS:-60}"

########################################################################################################################
# Print out the final value being used for each variable.
########################################################################################################################
echo "Using TENANT_NAME: ${TENANT_NAME}"
echo "Using SIZE: ${SIZE}"

echo "Using SUPPORTED_ENVIRONMENT_TYPES: ${SUPPORTED_ENVIRONMENT_TYPES}"
echo "Using IS_MULTI_CLUSTER: ${IS_MULTI_CLUSTER}"
echo "Using PLATFORM_EVENT_QUEUE_NAME: ${PLATFORM_EVENT_QUEUE_NAME}"
echo "Using CUSTOMER_SSO_SSM_PATH_PREFIX: ${CUSTOMER_SSO_SSM_PATH_PREFIX}"
echo "Using ORCH_API_SSM_PATH_PREFIX: ${ORCH_API_SSM_PATH_PREFIX}"
echo "Using SERVICE_SSM_PATH_PREFIX: ${SERVICE_SSM_PATH_PREFIX}"
echo "Using REGION: ${REGION}"
echo "Using REGION_NICK_NAME: ${REGION_NICK_NAME}"
echo "Using PRIMARY_REGION: ${PRIMARY_REGION}"
echo "Using TENANT_DOMAIN: ${TENANT_DOMAIN}"
echo "Using GLOBAL_TENANT_DOMAIN: ${GLOBAL_TENANT_DOMAIN}"
echo "Using PRIMARY_TENANT_DOMAIN: ${PRIMARY_TENANT_DOMAIN}"
echo "Using SECONDARY_TENANT_DOMAINS: ${SECONDARY_TENANT_DOMAINS}"
echo "Using PING_CLOUD_NAMESPACE: ${PING_CLOUD_NAMESPACE}"

echo "Using CLUSTER_STATE_REPO_URL: ${CLUSTER_STATE_REPO_URL}"
echo "Using SERVER_PROFILE_URL: ${SERVER_PROFILE_URL}"
echo "Using CLUSTER_STATE_REPO_PATH: ${REGION_NICK_NAME}"

echo "Using ARTIFACT_REPO_URL: ${ARTIFACT_REPO_URL}"
echo "Using PING_ARTIFACT_REPO_URL: ${PING_ARTIFACT_REPO_URL}"
echo "Using PD_MONITOR_BUCKET_URL: ${PD_MONITOR_BUCKET_URL}"
echo "Using LOG_ARCHIVE_URL: ${LOG_ARCHIVE_URL}"
echo "Using BACKUP_URL: ${BACKUP_URL}"

echo "Using MYSQL_SERVICE_HOST: ${MYSQL_SERVICE_HOST}"
echo "Using MYSQL_USER: ${MYSQL_USER}"
echo "Using MYSQL_PASSWORD: ${MYSQL_PASSWORD}"

echo "Using PING_IDENTITY_DEVOPS_USER: ${PING_IDENTITY_DEVOPS_USER}"

echo "Using K8S_GIT_URL: ${K8S_GIT_URL}"
echo "Using K8S_GIT_BRANCH: ${K8S_GIT_BRANCH}"

echo "Using SSH_ID_PUB_FILE: ${SSH_ID_PUB_FILE:-'<auto-generated>'}"
echo "Using SSH_ID_KEY_FILE: ${SSH_ID_KEY_FILE:-'<auto-generated>'}"

echo "Using PF_PROVISIONING_ENABLED: ${PF_PROVISIONING_ENABLED}"
echo "Using RADIUS_PROXY_ENABLED: ${RADIUS_PROXY_ENABLED}"
echo "Using ARGOCD_BOOTSTRAP_ENABLED: ${ARGOCD_BOOTSTRAP_ENABLED}"
echo "Using EXTERNAL_INGRESS_ENABLED: ${EXTERNAL_INGRESS_ENABLED}"
echo "Using TARGET_DIR: ${TARGET_DIR}"
echo "Using IS_BELUGA_ENV: ${IS_BELUGA_ENV}"

echo "Using ACCOUNT_BASE_PATH: ${ACCOUNT_BASE_PATH}"
echo "Using PGO_BUCKET_URI_SUFFIX: ${PGO_BUCKET_URI_SUFFIX}"
echo "Using ARGOCD_CDE_ROLE_SSM_TEMPLATE: ${ARGOCD_CDE_ROLE_SSM_TEMPLATE}"
echo "Using ARGOCD_CDE_URL_SSM_TEMPLATE: ${ARGOCD_CDE_URL_SSM_TEMPLATE}"
echo "Using ARGOCD_ENVIRONMENTS: ${ARGOCD_ENVIRONMENTS}"

echo "Using IRSA_PING_ANNOTATION_KEY_VALUE: ${IRSA_PING_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_PA_ANNOTATION_KEY_VALUE: ${IRSA_PA_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_PD_ANNOTATION_KEY_VALUE: ${IRSA_PD_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_PF_ANNOTATION_KEY_VALUE: ${IRSA_PF_ANNOTATION_KEY_VALUE}"
echo "Using IRSA_ARGOCD_ANNOTATION_KEY_VALUE: ${IRSA_ARGOCD_ANNOTATION_KEY_VALUE}"

echo "Using CLUSTER_ENDPOINT: ${CLUSTER_ENDPOINT}"

echo "Using KARPENTER_ROLE_ANNOTATION_KEY_VALUE: ${KARPENTER_ROLE_ANNOTATION_KEY_VALUE}"

echo "Using NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE: ${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}"

echo "Using SLACK_CHANNEL: ${SLACK_CHANNEL}"
echo "Using PROM_SLACK_CHANNEL: ${PROM_SLACK_CHANNEL}"

echo "Using APP_RESYNC_SECONDS: ${APP_RESYNC_SECONDS}"

echo "Using USER_BASE_DN: ${USER_BASE_DN}"

echo "Using IMAGE_LIST: ${IMAGE_LIST}"
echo "Using IMAGE_TAG_PREFIX: ${IMAGE_TAG_PREFIX}"
echo ---


########################################################################################################################
# Set variables for massaging files into correct structure for CSR
########################################################################################################################

TEMPLATES_HOME="${SCRIPT_HOME}/templates"
COMMON_TEMPLATES_DIR="${TEMPLATES_HOME}/common"
CHUB_TEMPLATES_DIR="${TEMPLATES_HOME}/customer-hub"
CDE_TEMPLATES_DIR="${TEMPLATES_HOME}/cde"

# Delete existing target directory and re-create it
rm -rf "${TARGET_DIR}"
mkdir -p "${TARGET_DIR}"

# Next build up the directory structure of the cluster-state repo
BOOTSTRAP_SHORT_DIR='fluxcd'
BOOTSTRAP_DIR="${TARGET_DIR}/${BOOTSTRAP_SHORT_DIR}"

CLUSTER_STATE_REPO_DIR="${TARGET_DIR}/cluster-state"
PROFILE_REPO_DIR="${TARGET_DIR}/profile-repo"
PROFILES_DIR="${PROFILE_REPO_DIR}/profiles"

CUSTOMER_HUB='customer-hub'
PING_CENTRAL='pingcentral'
PING_ACCESS='pingaccess'

mkdir -p "${BOOTSTRAP_DIR}"
mkdir -p "${CLUSTER_STATE_REPO_DIR}"
mkdir -p "${PROFILE_REPO_DIR}"

cp ./update-cluster-state-wrapper.sh "${CLUSTER_STATE_REPO_DIR}"
cp ./csr-validation.sh "${CLUSTER_STATE_REPO_DIR}"
cp ./values.yaml "${CLUSTER_STATE_REPO_DIR}"
cp ./values_region.yaml "${CLUSTER_STATE_REPO_DIR}"
cp ./seal-secret-values.py "${CLUSTER_STATE_REPO_DIR}"
cp ./update-profile-wrapper.sh "${PROFILE_REPO_DIR}"

cp ../.gitignore "${CLUSTER_STATE_REPO_DIR}"
cp ../.gitignore "${PROFILE_REPO_DIR}"

echo "${PING_CLOUD_BASE_COMMIT_SHA}" > "${TARGET_DIR}/pcb-commit-sha.txt"

# The SUPPORTED_ENVIRONMENT_TYPES variable can either be the CDE names (e.g. dev, test, stage, prod) or the CHUB name "customer-hub",
# or the corresponding branch names (e.g. v1.8.0-dev, v1.8.0-test, v1.8.0-stage, v1.8.0-master, v1.8.0-customer-hub).
# We must handle both cases. Note that the 'prod' environment will have a branch name suffix of 'master'.
for ENV_OR_BRANCH in ${SUPPORTED_ENVIRONMENT_TYPES}; do
# Run in a sub-shell so the current shell is not polluted with environment variables.
(
  ######################################################################################################################
  # Set the values for each environment specific variable.
  ######################################################################################################################

  if echo "${ENV_OR_BRANCH}" | grep -q "${CUSTOMER_HUB}"; then
    GIT_BRANCH="${CUSTOMER_HUB}"

    ENV_OR_BRANCH_SUFFIX="${CUSTOMER_HUB}"
    ENV="${CUSTOMER_HUB}"

    export CLUSTER_STATE_REPO_BRANCH="${CUSTOMER_HUB}"
  else
    test "${ENV_OR_BRANCH}" = 'prod' &&
        GIT_BRANCH='master' ||
        GIT_BRANCH="${ENV_OR_BRANCH}"

    ENV_OR_BRANCH_SUFFIX="${ENV_OR_BRANCH##*-}"
    test "${ENV_OR_BRANCH_SUFFIX}" = 'master' &&
        ENV='prod' ||
        ENV="${ENV_OR_BRANCH_SUFFIX}"

    # Set the cluster state repo branch to the default CDE branch, i.e. dev, test, stage or master.
    export CLUSTER_STATE_REPO_BRANCH="${GIT_BRANCH##*-}"
  fi

  # Export all the environment variables required for envsubst
  export ENV="${ENV}"
  export ENVIRONMENT_TYPE="\${ENV}"

  echo "-----> Starting to create environment '${ENV}'"

  # The base URL for kustomization files and environment will be different for each CDE.
  # On migrated customers, we must preserve the size of the customers.
  case "${ENV}" in
    dev | test)
      export KUSTOMIZE_BASE="${KUSTOMIZE_BASE:-test}"
      ;;
    stage | prod | customer-hub)
      export KUSTOMIZE_BASE="${KUSTOMIZE_BASE:-prod/${SIZE}}"
      ;;
  esac

  # Update the Let's encrypt server to use staging/production based on GA/MyPing customers or the environment type.
  PROD_LETS_ENCRYPT_SERVER='https://acme-v02.api.letsencrypt.org/directory'
  STAGE_LETS_ENCRYPT_SERVER='https://acme-staging-v02.api.letsencrypt.org/directory'

  if test ! "${LETS_ENCRYPT_SERVER}"; then
    if "${IS_GA}" || "${IS_MY_PING}"; then
      LETS_ENCRYPT_SERVER="${PROD_LETS_ENCRYPT_SERVER}"
    else
      case "${ENV}" in
        dev | test | stage)
          LETS_ENCRYPT_SERVER="${STAGE_LETS_ENCRYPT_SERVER}"
          ;;
        prod | customer-hub)
          LETS_ENCRYPT_SERVER="${PROD_LETS_ENCRYPT_SERVER}"
          ;;
      esac
    fi
  fi
  export LETS_ENCRYPT_SERVER="${LETS_ENCRYPT_SERVER}"

  # Set PF variables based on ENV
  if echo "${LETS_ENCRYPT_SERVER}" | grep -q 'staging'; then
    export PF_PD_BIND_PORT=1389
    export PF_PD_BIND_PROTOCOL=ldap
    export PF_PD_BIND_USESSL=false
  else
    export PF_PD_BIND_PORT=1636
    export PF_PD_BIND_PROTOCOL=ldaps
    export PF_PD_BIND_USESSL=true
  fi

  # Update the product specific variables based on environment.
  case "${ENV}" in
    dev | test)
      # Set PF variables
      export PF_MIN_HEAP=1536m
      export PF_MAX_HEAP=1536m
      export PF_MIN_YGEN=768m
      export PF_MAX_YGEN=768m

      # Set PA variables
      export PA_WAS_MIN_HEAP=1024m
      export PA_WAS_MAX_HEAP=1024m
      export PA_WAS_MIN_YGEN=512m
      export PA_WAS_MAX_YGEN=512m
      ;;
    stage | prod | customer-hub)
      # Set PF variables
      export PF_MIN_HEAP=3072m
      export PF_MAX_HEAP=3072m
      export PF_MIN_YGEN=1536m
      export PF_MAX_YGEN=1536m

      # Set PA variables
      export PA_WAS_MIN_HEAP=2048m
      export PA_WAS_MAX_HEAP=2048m
      export PA_WAS_MIN_YGEN=1024m
      export PA_WAS_MAX_YGEN=1024m
      ;;
  esac

  "${IS_BELUGA_ENV}" &&
      export CLUSTER_NAME="${TENANT_NAME}" ||
      export CLUSTER_NAME="${ENV}"

  CLUSTER_NAME_LC="$(echo "${CLUSTER_NAME}" | tr '[:upper:]' '[:lower:]')"
  export CLUSTER_NAME_LC="${CLUSTER_NAME_LC}"

  add_derived_variables

  #IRSA_TEMPLATE='eks.amazonaws.com/role-arn: arn:aws:iam::${ssm_value}:role/pcpt/irsa-roles'
  # shellcheck disable=SC2016

  # TODO: validate this new int contract with Versent before merging!
  IRSA_TEMPLATE='eks.amazonaws.com/role-arn: ${ssm_value}'

  # TODO: is this going to be just ping?
  set_var "IRSA_PING_ANNOTATION_KEY_VALUE" "" "${IRSA_BASE_PATH}" "ping/arn" "${IRSA_TEMPLATE}"
  set_var "IRSA_PA_ANNOTATION_KEY_VALUE" "" "${IRSA_BASE_PATH}" "pingaccess/arn" "${IRSA_TEMPLATE}"
  set_var "IRSA_PD_ANNOTATION_KEY_VALUE" "" "${IRSA_BASE_PATH}" "pingdirectory/arn" "${IRSA_TEMPLATE}"
  set_var "IRSA_PF_ANNOTATION_KEY_VALUE" "" "${IRSA_BASE_PATH}" "pingfederate/arn" "${IRSA_TEMPLATE}"

  # TODO: should this change to just argocd?
  set_var "IRSA_ARGOCD_ANNOTATION_KEY_VALUE" "" "${IRSA_BASE_PATH}" "irsa-argocd/arn" "${IRSA_TEMPLATE}"

  # TODO: is this already agreed to? Seems like we should make it consistent as well - irsa_base_path/karpenter/arn
  set_var "KARPENTER_ROLE_ANNOTATION_KEY_VALUE" "" "${ACCOUNT_BASE_PATH}" "${ENV}" "${IRSA_TEMPLATE}"

  # shellcheck disable=SC2016
  #KARPENTER_ROLE_TEMPLATE='eks.amazonaws.com/role-arn: arn:aws:iam::${ssm_value}:role/pcpt/KarpenterControllerRole'

  set_var "CLUSTER_ENDPOINT" "" "${ACCOUNT_BASE_PATH}${ENV}" "/cluster-endpoint"

  # shellcheck disable=SC2016
  NLB_TEMPLATE='service.beta.kubernetes.io/aws-load-balancer-eip-allocations: ${ssm_value}'
  set_var "NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE" "" "${NLB_EIP_PATH_PREFIX:-unused}" "/${ENV}/nginx-public" \
          "${NLB_TEMPLATE}"

  set_var "PGO_BACKUP_BUCKET_NAME" "not_set" "${ACCOUNT_BASE_PATH}${ENV}" "${PGO_BUCKET_URI_SUFFIX}"
  # Remove s3:// prefix if present
  export PGO_BACKUP_BUCKET_NAME=${PGO_BACKUP_BUCKET_NAME#s3://}

  ######################################################################################################################
  # Print out the final value being used for each environment specific variable.
  ######################################################################################################################
  echo ---
  echo "For environment ${ENV}:"
  echo "Using CLUSTER_STATE_REPO_BRANCH: ${CLUSTER_STATE_REPO_BRANCH}"
  echo "Using ENVIRONMENT_TYPE: ${ENVIRONMENT_TYPE}"
  echo "Using KUSTOMIZE_BASE: ${KUSTOMIZE_BASE}"
  echo "Using LETS_ENCRYPT_SERVER: ${LETS_ENCRYPT_SERVER}"
  echo "Using CLUSTER_NAME: ${CLUSTER_NAME}"
  echo "Using DNS_ZONE: ${DNS_ZONE}"
  echo "Using PRIMARY_DNS_ZONE: ${PRIMARY_DNS_ZONE}"
  echo "Using PGO_BACKUP_BUCKET_NAME: ${PGO_BACKUP_BUCKET_NAME}"
  echo "Using IRSA_PING_ANNOTATION_KEY_VALUE: ${IRSA_PING_ANNOTATION_KEY_VALUE}"
  echo "Using NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE: ${NLB_NGX_PUBLIC_ANNOTATION_KEY_VALUE}"

  ######################################################################################################################
  # Massage files into correct structure for push-cluster-state script
  ######################################################################################################################

  ####### Bootstrap logic ##############################################################################################
  echo "Generating bootstrap yaml for ${ENV}"
  ENV_BOOTSTRAP_DIR="${BOOTSTRAP_DIR}/${ENV_OR_BRANCH}"
  mkdir -p "${ENV_BOOTSTRAP_DIR}"
  cp "${TEMPLATES_HOME}/${BOOTSTRAP_SHORT_DIR}"/common/* "${ENV_BOOTSTRAP_DIR}"
  if [[ "${ENV}" == "${CUSTOMER_HUB}" || "${IS_BELUGA_ENV}" == "true" ]]; then
    cp "${TEMPLATES_HOME}/${BOOTSTRAP_SHORT_DIR}"/customer-hub/* "${ENV_BOOTSTRAP_DIR}"
    # Copy all files from customer-hub code-gen, except kustomization.yaml to re-use the yaml there and prevent duplication
    find "${CHUB_TEMPLATES_DIR}/base/cluster-tools/git-ops" -type f ! -name kustomization.yaml | xargs -I {} cp {} "${ENV_BOOTSTRAP_DIR}"
    # Append the regional env-vars to the common env_vars to make sure all env vars are available for initial bootstrap
    cat "${CHUB_TEMPLATES_DIR}/region/git-ops/env_vars" >> "${ENV_BOOTSTRAP_DIR}/env_vars"
  else
    cp "${TEMPLATES_HOME}/${BOOTSTRAP_SHORT_DIR}"/cde/* "${ENV_BOOTSTRAP_DIR}"
  fi
  substitute_vars "${ENV_BOOTSTRAP_DIR}" "${BOOTSTRAP_VARS}"
  ####### END Bootstrap logic ##########################################################################################

  # Copy the shared cluster tools and Ping yaml templates into their target directories
  echo "Generating tools and ping yaml for ${ENV}"

  ENV_DIR="${CLUSTER_STATE_REPO_DIR}/${ENV_OR_BRANCH}"
  mkdir -p "${ENV_DIR}"

  K8S_CONFIGS_DIR="${ENV_DIR}/k8s-configs"
  mkdir -p "${K8S_CONFIGS_DIR}"

  cp ../k8s-configs/cluster-tools/base/git-ops/git-ops-command.sh "${K8S_CONFIGS_DIR}"

  # Copy the templates directory files (ex: seal.sh, region-promotion.txt) to the tmp dir
  find "${TEMPLATES_HOME}" -type f -maxdepth 1 | xargs -I {} cp {} "${K8S_CONFIGS_DIR}"

  # Copy the common templates first.
  cd "${COMMON_TEMPLATES_DIR}"
  rsync -rR * "${K8S_CONFIGS_DIR}"
  cd - >/dev/null 2>&1

  # Overlay the CHUB or CDE specific templates next.
  if test "${ENV}" = "${CUSTOMER_HUB}"; then
    cd "${CHUB_TEMPLATES_DIR}"
  else
    cd "${CDE_TEMPLATES_DIR}"
  fi

  rsync -rR * "${K8S_CONFIGS_DIR}"
  cd - >/dev/null 2>&1

  # Rename to the actual region nick name.
  mv "${K8S_CONFIGS_DIR}/region" "${K8S_CONFIGS_DIR}/${REGION_NICK_NAME}"

  # Massage files from new microservice architecture
  organize_code_for_csr

  PRIMARY_PING_KUST_FILE="${K8S_CONFIGS_DIR}/${REGION_NICK_NAME}/kustomization.yaml"

  # Copy around files for Developer CDE before substituting vars
  if "${IS_BELUGA_ENV}"; then
    # Add IS_BELUGA_ENV to the base env_vars
    BASE_ENV_VARS="${K8S_CONFIGS_DIR}/base/env_vars"
    echo >> "${BASE_ENV_VARS}"
    echo "IS_BELUGA_ENV=true" >> "${BASE_ENV_VARS}"

    # Update patches related to Beluga developer CDEs
    sed -i.bak 's/^# \(.*remove-from-developer-cde-patch.yaml\)$/\1/g' "${PRIMARY_PING_KUST_FILE}"
    rm -f "${PRIMARY_PING_KUST_FILE}.bak"

    # Add ArgoCD to Beluga Environments since it normally runs only in customer-hub
    echo "This is a Beluga Development Environment, copying ArgoCD into the CSR"
    cp -R "${CHUB_TEMPLATES_DIR}/base/cluster-tools/git-ops" "${K8S_CONFIGS_DIR}/base/cluster-tools/"

    # Append the secrets from customer-hub to the CDE secrets, except PingCentral since that doesn't exist in the CDE
    printf "\n# %%%% NOTE: Below secrets are for the Developer CDE only (when IS_BELUGA_ENV is 'true') to make sure Argo works properly %%%%#\n" >> "${K8S_CONFIGS_DIR}/base/secrets.yaml"
    yq 'del(select(.metadata.name | contains("pingcentral")))' "${CHUB_TEMPLATES_DIR}/base/secrets.yaml" >> "${K8S_CONFIGS_DIR}/base/secrets.yaml"
    printf "\n# %%%% END automatically appended secrets from generate-cluster-state.sh\n" >> "${K8S_CONFIGS_DIR}/base/secrets.yaml"
  fi

  echo "Substituting env vars, this may take some time..."
  substitute_vars "${ENV_DIR}" "${REPO_VARS}" secrets.yaml env_vars

  echo "Substituting values.yaml"
  substitute_vars "${CLUSTER_STATE_REPO_DIR}" "${REPO_VARS}" values.yaml values_region.yaml
  # TODO: These duplicate calls are needed to substitute the derived variables & the IS_BELUGA_ENV in values files
  #  clean this up with PDO-4842 when all apps are migrated to values files by adding IS_BELUGA_ENV to DEFAULT_VARS
  #  and redoing how derived variables are set
  substitute_vars "${CLUSTER_STATE_REPO_DIR}" "${REPO_VARS}" values.yaml values_region.yaml
  substitute_vars "${CLUSTER_STATE_REPO_DIR}" '${IS_BELUGA_ENV}' values.yaml

  # Regional enablement - add admins, backups, etc. to primary and adding pingaccess-was and pingcentral to primary.
  if test "${TENANT_DOMAIN}" = "${PRIMARY_TENANT_DOMAIN}"; then
    sed -i.bak 's/^\(.*remove-from-secondary-patch.yaml\)$/# \1/g' "${PRIMARY_PING_KUST_FILE}"
    rm -f "${PRIMARY_PING_KUST_FILE}.bak"
  fi

  echo "Copying server profiles for environment ${ENV}"
  ENV_PROFILES_DIR="${PROFILES_DIR}/${ENV_OR_BRANCH}"
  mkdir -p "${ENV_PROFILES_DIR}"

  cp -pr ../profiles/aws/. "${ENV_PROFILES_DIR}"

  if test "${ENV}" = "${CUSTOMER_HUB}"; then
    # Retain only the pingcentral & pingaccess profiles
    find "${ENV_PROFILES_DIR}" -type d -mindepth 1 -maxdepth 1 -not -name "${PING_CENTRAL}" -not -name "${PING_ACCESS}" -exec rm -rf {} +
  else
    # Remove the pingcentral profiles
    rm -rf "${ENV_PROFILES_DIR}/${PING_CENTRAL}"
  fi

  echo "=====> Done creating environment '${ENV}'"
)
done

cp -p push-cluster-state.sh "${TARGET_DIR}"

# Go back to previous working directory, if different
popd >/dev/null 2>&1

if ! "${QUIET}"; then
  echo
  echo '------------------------'
  echo '|  Next steps to take  |'
  echo '------------------------'
  echo "1) Run ${TARGET_DIR}/push-cluster-state.sh to push the generated code into the tenant cluster-state repo:"
  echo "${CLUSTER_STATE_REPO_URL}"
  echo
  echo "2) Add the following identity as the deploy key on the cluster-state (rw), if not already added:"
  echo "${SSH_ID_PUB}"
  echo
  echo "3) Deploy bootstrap files onto each CDE by navigating to ${BOOTSTRAP_DIR} and running:"
  echo 'kustomize build | kubectl apply -f -'
fi
